Undefined behavior - when accessing an array out of bounds

Implementation dependent behavior - 17/-5  Can result in two answers.  Left to compiler writer to determine what the right answer is

Visual C++ -  Microsoft compiler

g++/gcc - Used on Linux and Mac.  Problems are that it has been around a very long time.  Accumulated and is complicated.  Hard to do things with source code other than compile it.

clang/clang++ -  Started from scratch.  Gives access to parse trees and static analyzers.  Virtual machine to compile to native code.  Much better error messages on the front end.  Can be installed on Windows and is nice to use because error messages are clearer.

Standardization of the language did not arise until 1998. C++98 is the common standardization.
C++11 is what we will be using in this class.

Char is really an integer type.  It is only one byte long.

Order of when functions are called on the same line, is not known in CPP.  It is dependent on the compiler.

C++11 for loop:
in a[] {1,2,3};
for (auto val : a)
{
  ...
}
Only use this if you want to visit every item.

Functions need to be declared before the main function.  This is so main knows the arguments and that it exists.

Static local variables can only be initialized once and only the first time we reach that declaration.

& is a pass by reference item in C++.  Therefore when passing by reference, the actual object changes, as where pass by value copies the value over.  Pointer implementation would have the method call using the & sign.

References are bound to that object for the life of that reference.  Pointers can be inter-changable and point to different memory addresses.

Arrays by default pass pointers, does not pass by value.

Const keyword modifies the array and making it immutable.  Therefore, the function cannot modify the array.  Pass by value requires const.

Default values can be supplied in prototype function.  Prototype is the signature without the implementation.

Inline is a hint that the implementation is so fast that you don't need to make a function call.  Function calls are expensive.

Lesson Three:

C++ is a strongly typed language.

const cannot be modified and is relative to the scope of the object.  Const needs to be initialized at the time of declaration of the variable

typedef creates a synonym for an existing type so rather than having the type written everywhere, use typedef to create a synonym for that type.

New syntax for C++11 is:
using ID = unsigned short;

Syntax previously used:
typedef unsigned short ID;

enumeration is a set of symbolic constants.  Implemented as integers.

End each case with break;  Omitting the break means that the same behavior will be applied to multiple cases.

C++11 will allow the type to be specified when doing enumerations. (Short, int, long)

C++11 allows that the constants determined in an enumeration can be specified and not remain ambiguious

Full name of the type is scoped.  For instance, in this method, DAY::SUNDAY

'\0'  Represents the end of a string since a string is just an array of characters.  The c++ library adds <cstring> which helps support strings in c++

C++ also introduces <string> library.  Now part of the standard library and will get the appropriate length required.

using directive allows the namespace to be dropped from using functions. e.g.:
using namespace std;
cout << "Hello"; versus -> std::cout << "Hello";

struct defines an aggregate data type, semi-colan required at the end of a struct definition.

dot operator used to access members of a data type StructType.DataMember

If you are going to pass by value, this can be an expensive operation.  Instead, use const and the '&' pass by reference operator.

depends on how cheap it is to pass by value.  Built in data types are good to pass by value and very small structures.

Overloading... Multiple functions with the same name but different signatures....

Sometimes implicit converting can cause ambigious calls can be generated from function overloading.

Template makes a definition for a function that has essentially the same logic.  Keyword template is used and will replace T with the type that is needed.

What can go wrong?

1)  We might not match the template.

2)  The template matches but the instantiation fails because the matches don't compile.

3)  Template matches, code compiles, won't do what you want.  For instance, comparing two cstrings it will return whatever memory address is higher.

How to remedy, create specific overloads.  non-template functions beat out template functions when comparing two functions that are overloaded.  That way special exceptions win out in the compiler.

Lesson 4 & 5 - Member Variables

member functions are contained within the struct
Member names start with an underscore.  This is to prevent things from getting confused.
shares versus m_shares or shares_
This prevents confusion between data members and other local variables.

Passing by reference with an object causes a compile error when we are calling a function of that object.

Must declare const on the prototype function to avoid the compile error in the declaration and the implementation.

Constructor can throw an exception if it cannot create an object.

Delegating constructors.  Used for overloading and can be used for additional items as well.  This changes the way we can do things.  Available at c++11

Can create a default constructor which takes no arguments.  These should seem natural.  Default constructor has no () e.g.:
Position acme; NOT Position acme();

C++11 can initialize a default value to use if the constructor does not.

Destructor looks like ~Constructor();  Automatically called whenever an object of a type goes away.  Only required for clean-up of special types.  Difference between Java/C# and CPP is that we don't know when garbage collection occurs whereas in cpp we know when it is called.

If there are no default constructors, creating an array of objects will not compile.  This is because an array creates the objects as it is instantiated.

Vectors are a dynamically resizeable array.  It creates a list of items but its empty.  Therefore, if we wanted to create an array without a default constructor, a vector data structure may be a better choice.

Lesson 6 - Access Control (Encapsulation)

public members or private member data types.  private: and then everything that follows is private.

A struct is a class a class is a struct.  In a class, access control defaults to private whereas in struct it defaults to public.  Must explicitely declare members public in a class.

Helper functions can be created privately to help set values in the code.

Friend functions should be rare.  Allows external functions to access private members.

Access control is cost free at runtime, its something that occurs at compile time.

Lesson 7 - Inheritance 1

A class to represent base objects and then to inherit use:
struct Employee : Person
Employee is the new class and person is the base class(Super class).

Default inheritance is private for a class so when using a class to inherit is you need to declare the base class as public if needed.

If invoking a base class function in a class that inherits it, we need to qualify it to the base class.

C++ class can have more than one base class.

Private members of base classes are not accessible to derived classes.

Protected members are visible ot descendant classes but not to classes outside of the hierarchy.

Don't make data anything other than private.  Do protected functions to protect data.

Inheritance has no additional overhead.  This means that everything is aggregated at compile time rather than runtime.

Lesson 8 - Virtual Functions 1

Dynamic binding - use the function of the derived object rather than the base class.

declaring member functions as virtual, means that anything inherited by that object will be dynamically bound.  Once the base class function is declared virtual, it does not have to be declared as virtual in the derived classes but it helps make code more readable.

Virtual functions employ dynamic binding rather than static.

To override, the functions need to match exactly in signature.

The keyword override will check to see if it overrides the function and can throw a compiler error for checking.

Override is only a keyword in the context of a function declaration.

Static binding is by default in C++ (no virtual keyword).

final at the end of a declaration of a base class does not allow derrived classes to override an implementation.

Lesson 9 - Templates

Client specializes the class template to the desired type.

Have a variety of classes with different types in the same program.

Templates can have multiple values.  For instance, a Map template (dictionary) can match a name to a phone number.

Template parameters can also be compile-time constants. Template parameters can also have default values for these compile-time constants.

Templates have 0 runtime costs whereas virtual functions have runtime costs.

Can potentially increase the size of the EXE generated for the program because of the potential implementation of templates.

Lesson 10 - Pointers

* suffix declares a pointer.

Pointer holds an indication where something is

& operator generates a pointer.  for instance:
int x;
int* p;
p = &x;

if we want to talk about the int that p points to, we would use a * to show the object that p points to.

C++ can point into an array which a lot of other languages do not have that ability.

subscripting with pointer is valid.  For instance:
int* a = &data[0];
int* b = &data[1];
b[-1] == a[0];

Pointers can have arthimetic applied to them.
int* p;
p += 5;
Moves ahead 5 elements in the array.

for loop assigning every value to 42 using pointers of an array da
int da[5];
int* dp;
for(dp=da; dp < da+5; dp++)
{
  *dp = 42;
}

using pointers in looping arrays should theoretically be faster but any optimized compiler today should be good for arrays.

Uses the pointer style when working with vectors/linked list/custom data types...
Same syntax as arrays because the ++ operator is overloaded to take you to the next item in the custom data type.

Dot operator is for a reference to that type and a -> operator is used for a pointer of a certain type.

this is a pointer when used within a member function so we would need to use -> operator when using this in a member function.

One use of pointers in C is to update the reference to your data.
Another use is to traverse an array.
Another use is express relationships in data structures.

Rather than contain a collection of something, contain a collection of pointers.

Use incomplete type specifications when needing to use something before it is implemented.
Known as a forward declaration.  Cannot use if a containing data type is in the class, can only use with pointers.

nullptr is a well defined value that doesn't point to anything.  Not much that can be done with it.  Used for equality or inequality but cannot do anything with it.  It is the neutral value equivalent like zero is for numerical types.

When needing to use pre-C++11 compilers, using a 0 is a nullptr.

Undefined behavior to try to follow the nullptr.

Lesson 11 - Dynamic Memory 1

Pointers are used when we use dynamic memory.

If its a local variable it lives on the runtime stack.  When the function returns, the variables go away.

Variables declared outside any function or as static.  They live in the static storage area and lives for the duration of the program.

new and delete operators uses memory from the heap (free store)

new will allocate memory and do initialization and returns a pointer.

delete will perform deconstruction and release memory.  It will not create a nullptr but will leave a dangling pointer.  A pointer to storage that no longer belongs to us and is undefined behavior to follow that pointer.

Maybe a object is expensive to construct.  Rather than construct it, use dynamic memory allocation to construct it only if we need it.

We can create functions to establish the object or get rid of the object.

Calling the new keyword twice without calling delete between causes memory leaks.  It allocates space in the heap without deallocating the previous space.

Can use constructor arguments with new keywork.  Calling delete with a nullptr is totally ok.

use [] with new and delete to dynamically decide the size of an array at runtime. for arrays, use the delete [] arrayPtrName; syntax

Reallocating a pointer to a new dynamic memory set causes a memory leak.  We need to call the delete keyword.

nothrow throws an exception if an allocation cannot occur.

Dynamic allocation is slower for data types as there is more overhead for managing the free store.

Lesson 14 - Dynamic Memory 2

Classes may dynamically allocate internally.  If the class has any dynamic objects that it points to, the destructor needs to call the delete object on that pointer.  The reason the destructor is called is because the object is going away, therefore, the delete to a dynamically allocated pointer needs to be called.

(templates) Pointers may use members to grow dynamically.

This can be used to create data types that manages its own storage.  (Std library vector, string, etc...)

Assignment.  Default behavior for assignment is memberwise assignment which is problematic for pointer members.

When assigning the pointer, you are not deallocating the space it was originally pointing to.  On top of that, when the destructor is called on pointer one it deallocates the space.  When it is called on pointer 2, it runs into space that is not allocated which can cause issues.

When using pointers and dynamically allocated memory, the assignment operator needs to be overridden to call the destructor of the original pointer and then assign it to the new one.  Convention is to return a reference.

Aliasing - when assigning an object to itself.  Having more than one object assigned to the same object.
Do a self assignment check to avoid problems.

Copying is another resource allocation problem when working with pointers and dynamic memory.

When copying a template, the pointer gets copied.  Therefore, the pointer points to the same location, not a different dynamically allocated memory location.

So in certain scenarios, the compiler cannot determine how we copy information.  We need to define it.

Initialization would call a constructor.  There is a copy constructor that overrides the default memberwise copy.

Can share code between copy constructor and the assignment operator.

if trying to swap objects and want to do it cheaply, we could just swap the pointers using the standard 3 way stop.

Copy-and-Swap Idioim  and is used as a popular way to reassign data.

The classic rule of three says that if you need to write one of the following you will need to write the other two:

Copy constructor
Assignment operator
destructor

Lesson ??? - Standard Smart Pointers

We can accidentally hold locks and miss deleting items that need to be deleted creating memory leaks.

A new convention on how to avoid these problems was created.

Smart pointer is for anything that acts like a pointer but whose behavior throws exceptions and what not.

There is a unique pointer and a shared pointer.

Inclued the header memory which includes there pointers.  A unique pointer is in a context where you only want one pointer pointing to a data type.  Cannot copy unique pointers.  Unique pointers destructor releases the object.

These are raw pointers at initalization but then you dynamically control the object and immediately pass the unique pointer to a constructor.

shared pointers automatically releases dynamic memory once all std::shared_ptrs to the memory fo out of scope.

Smart pointers act like raw pointers.

Unique pointers can be used for arrays whereas shared pointers cannot be used for arrays.

RAII classes are types that release their pointer at destruction to prevent memory leaks.  Resource Acquisition is Initialization

RAII classes are able to prevent resource leaks.

Vectors are similar to Arrays

Lesson 15 - Exceptions

How does a low level routine alert a high level routine to show the error.

Exceptions are an error notification mechanism.

The exception is thrown and it will propegate until it is caught.

Exceptions can be objects.  Therefore, we can get more information rather than just the error code.

Catch by reference when catching exceptions.

The appropriate handler needs to be choosen by the type thrown.

catch(...)  <- catches any exception.  However, there is not much that can be done with it.

Throwing exception invokes destructors for local objects.

.
